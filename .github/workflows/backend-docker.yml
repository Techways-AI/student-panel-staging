name: Deploy Backend to ECS

on:
  workflow_dispatch:


env:
  AWS_REGION: ${{ vars.AWS_REGION || 'ap-south-1' }}
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION || 'ap-south-1' }}
  ECR_REPO_NAME: ${{ vars.ECR_REPO_NAME || 'backend' }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER || 'mycluster-app' }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE || 'student-backend-task-service-bohrme8j' }}
  TASK_FAMILY: ${{ vars.TASK_FAMILY || 'student-backend-task' }}
  CONTAINER_NAME: ${{ vars.CONTAINER_NAME || 'backend' }}
  S3_BUCKET: ${{ vars.S3_BUCKET || 'durranis-bpharma-data' }}
  DATABASE_URL: ${{ vars.DATABASE_URL || 'postgresql://postgres:Dur!Ns_2025@durrani-db-cluster.ct480m0y4qz1.ap-south-1.rds.amazonaws.com:5432/durrani_db' }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com

      - name: Build, tag, and push Docker image
        run: |
          IMAGE_URI=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO_NAME:latest
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

          docker build -t $IMAGE_URI ./apps/api
          docker push $IMAGE_URI

      - name: Install jq for JSON processing
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Check current service status
        run: |
          echo "üîç Checking current ECS service status..."
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query "services[0].{status: status, desiredCount: desiredCount, runningCount: runningCount, pendingCount: pendingCount}" \
            --output table

      - name: Prepare new ECS task definition with PostgreSQL environment
        run: |
          aws ecs describe-task-definition \
            --task-definition $TASK_FAMILY \
            --query "taskDefinition" \
            --output json > task-def.json

          jq 'del(
              .taskDefinitionArn,
              .revision,
              .status,
              .requiresAttributes,
              .compatibilities,
              .registeredAt,
              .registeredBy
            )' task-def.json > cleaned-task-def.json

          # Update image and add PostgreSQL environment variables
          jq --arg IMAGE "$IMAGE_URI" \
             --arg CONTAINER "$CONTAINER_NAME" \
             --arg DATABASE_URL "$DATABASE_URL" \
             --arg JWT_SECRET_KEY "${{ secrets.JWT_SECRET_KEY }}" \
             --arg OPENAI_API_KEY "${{ secrets.OPENAI_API_KEY }}" \
             --arg AWS_ACCESS_KEY_ID "${{ secrets.AWS_ACCESS_KEY_ID }}" \
             --arg AWS_SECRET_ACCESS_KEY "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
             --arg AWS_REGION "$AWS_REGION" \
             --arg S3_BUCKET "$S3_BUCKET" \
             '(.containerDefinitions[] | select(.name == $CONTAINER)).image = $IMAGE | 
              (.containerDefinitions[] | select(.name == $CONTAINER)).environment = [
                {"name": "DATABASE_URL", "value": $DATABASE_URL},
                {"name": "JWT_SECRET_KEY", "value": $JWT_SECRET_KEY},
                {"name": "OPENAI_API_KEY", "value": $OPENAI_API_KEY},
                {"name": "AWS_ACCESS_KEY_ID", "value": $AWS_ACCESS_KEY_ID},
                {"name": "AWS_SECRET_ACCESS_KEY", "value": $AWS_SECRET_ACCESS_KEY},
                {"name": "AWS_REGION", "value": $AWS_REGION},
                {"name": "S3_BUCKET", "value": $S3_BUCKET}
              ] | .' \
             cleaned-task-def.json > new-task-def.json

          aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --region $AWS_REGION
        env:
          IMAGE_URI: ${{ env.IMAGE_URI }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          TASK_FAMILY: ${{ env.TASK_FAMILY }}
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Update ECS service with new task revision
        run: |
          NEW_TASK_REVISION=$(aws ecs describe-task-definition \
            --task-definition $TASK_FAMILY \
            --query "taskDefinition.revision" \
            --output text)

          echo "üîÑ Updating ECS service with task revision: $NEW_TASK_REVISION"
          
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $TASK_FAMILY:$NEW_TASK_REVISION \
            --force-new-deployment

      - name: Wait for service to stabilize (with timeout and debugging)
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize..."
          echo "This may take up to 10 minutes..."
          
          # Wait for service to stabilize with timeout
          timeout 600 bash -c '
            while true; do
              STATUS=$(aws ecs describe-services \
                --cluster $ECS_CLUSTER \
                --services $ECS_SERVICE \
                --query "services[0].status" \
                --output text)
              
              RUNNING=$(aws ecs describe-services \
                --cluster $ECS_CLUSTER \
                --services $ECS_SERVICE \
                --query "services[0].runningCount" \
                --output text)
              
              DESIRED=$(aws ecs describe-services \
                --cluster $ECS_CLUSTER \
                --services $ECS_SERVICE \
                --query "services[0].desiredCount" \
                --output text)
              
              echo "üìä Service Status: $STATUS, Running: $RUNNING/$DESIRED"
              
              if [ "$STATUS" = "ACTIVE" ] && [ "$RUNNING" = "$DESIRED" ] && [ "$RUNNING" -gt 0 ]; then
                echo "‚úÖ Service is stable!"
                break
              fi
              
              echo "‚è≥ Still waiting... (30s)"
              sleep 30
            done
          ' || {
            echo "‚ùå Service stabilization timeout reached"
            echo "üîç Checking service events for debugging..."
            aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE \
              --query "services[0].events[0:5]" \
              --output table
            exit 1
          }

      - name: Verify deployment
        run: |
          echo "‚úÖ Deployment completed successfully!"
          echo "üîç Final service status:"
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query "services[0].{status: status, desiredCount: desiredCount, runningCount: runningCount, pendingCount: pendingCount}" \
            --output table

      - name: Check service events (for debugging)
        if: always()
        run: |
          echo "üìã Recent service events:"
          aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query "services[0].events[0:3]" \
            --output table

